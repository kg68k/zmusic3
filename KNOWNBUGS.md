# 既知の不具合

## ZMSC3.X

* メモリ確保ルーチン(`get_mem:`): 下記不具合はファンクション`$70 ZM_GET_MEM`など、
  メモリ確保を行う機能すべてに影響する。
  * 確保サイズ(`d2.l`)に`-8`を指定するとエラー(`ILLEGAL_MEMORY_BLOCK_SIZE`)にならず、確保した
    メモリブロック範囲外に書き込みを行いバスエラーが発生したり、メモリ内容を破壊してしまう。
  * メモリが確保できなかった場合、エラー処理ルーチンが呼ばれエラー情報用のメモリが確保される。
    このメモリも確保できなかった場合はエラー処理が繰り返されるため、スタックオーバーフローを
    起こしてハングアップ等が発生する。
* ファンクション`$13 ZM_SE_ADPCM1`
  * MPCM.X非常駐時、優先度が低くて再生されない場合の戻り値`d0.l`の値が不定(0以外の値にはなる)。
  * MPCM.X常駐時、成功すると`d0.l`に0以外の値が返る。
    * MPCMの不具合の影響を受けているが、それだけではなくマニュアル記載の仕様ではMPCM`M_EFCT_OUT`
      は「d0.l≧0 正常終了」であるのに対し、ZMSC3.X`ZM_SE_ADPCM1`は「d0.l=0:正常終了」であるので、
      戻り値の上書きが必要だがこれをしていない。
* ファンクション`$73 ZM_FREE_MEM2`
  * 小さいメモリブロックがあるとメモリブロック範囲外のメモリを読んでしまう。その場所にメモリが
    実装されていなければバスエラーが発生する。
  * メモリブロックを確保したプロセスがZMSC3.Xか確認していないため、メモリ管理ポインタの直後の
    メモリ内容がメモリ用途IDと偶然一致するとZMSC3.Xで確保したメモリと誤認して解放してしまう。
  * 常駐時、常駐解除時、ドライバ初期化時、そのほかさまざまなところで`ZM_FREE_MEM2`を使用しており
    この不具合の影響を受ける。
* ファンクション`$74 ZM_EXCHANGE_MEMID` (引数`d1.l=-1`を指定した場合)
  * 小さいメモリブロックがあるとメモリブロック範囲外のメモリを読んでしまう。その場所にメモリが
    実装されていなければバスエラーが発生する。
  * メモリブロックを確保したプロセスがZMSC3.Xか確認していないため、メモリ管理ポインタの直後の
    メモリ内容がメモリ用途IDと偶然一致するとZMSC3.Xで確保したメモリと誤認して変更してしまう。

## ZMC.X

* 上限下限あり8ビット値の配列で、値の直後の2連続セパレータが単独のセパレータとして解釈されてしまう。
  ([@kg68k/1482025079017926658](https://x.com/kg68k/status/1482025079017926658))
* 上限下限あり16ビット値の配列で、上限値・下限値が正しく適用されないことがある。
  ([@kg68k/1482027532736245763](https://x.com/kg68k/status/1482027532736245763))
* `.FM_TUNE_SETUP`をint16_tではなくint8_tとしてコンパイルしてしまう。
  ([@arith_rose/1481388558246051842](https://x.com/arith_rose/status/1481388558246051842))
* 参考情報：隠し機能かもしれない挙動。
  * `@Kn1,n2,dly,bnd`、`@Bn1,n2,dly,bnd`のdlyに-32768～-1を指定できる。
* 参考情報：ZMDフォーマット(ZM12.MAN)では対応しているが、ZMC.Xの動作やMMLコマンド解説(ZM5.MAN)では
  使用できない数値指定。
  * `U±n`、`@U±n`、`Kn`、`@P±n`、`[VOLUME v]`、`[@VOLUME v]`、`[VELOCITY u]`、`[@VELOCITY u]`、
    `[PANPOT p]`、`[@PANPOT p]`、`[CH_PRESSURE n]` の下限は-127だが、ZMD仕様では-128。
  * `_n`の上限は127だが、ZMD仕様では128(ZMDデータ上は-128)。
  * `@Kn1,n2,dly,bnd`と`@Bn1,n2,dly,bnd`のbnd、`@Qn`の下限は-32767だが、ZMD仕様では-32768。

## ZP3.R

* ファイル名を大文字ドライブ名指定すると、そのドライブに対し特殊ブロックデバイス用の
  `DOS _DRVCTRL (MD=$34xx)`を発行し、返り値によってはファイルがあってもオープンできない。
    * FOPEN.HAS::check_drvchgで`d0`レジスタ(の上位バイト)を初期化していないため。
* 空きメモリが少ない状態で実行するとプロセスのメモリブロック範囲外を読み書きすることがある。
  これによりバスエラーやハングアップなどが起きる。

## ZVT.X version 2.09

* グラフィック画面の使用状況が3(破壊)だとエラー終了してしまう。
* グラフィック画面が使用できない場合にエラーメッセージの後に使用法を表示してしまう。
* version 2.09 patchlevel 1で修正されている。

## マニュアル(ZM302_M.LZH)

* ZM4.MAN
  * `.FM_TUNE_SETUP`、`.ADPCM_TUNE_SETUP`のt1～t128の値の上限が+32768と書かれている(本文は正しい)。
* ZM5.MAN
  * 値の範囲をA-Bと表記しているものと、A～Bと表記しているものがあり統一されていない。
  * `[TRACK_DELAY n]`のnの上限は32768ではなく32767。
  * `[VELOCITY u]`の「・u:-127～+127」は「・u:0～127」が正しい。
* ZM10.MAN
  * ファンクション`$13 ZM_SE_ADPCM1`、`$14 ZM_SE_ADPCM2`の「d4.lw:再生チャンネル(0-15)」は、
    正しくは「d4.lw:再生チャンネル(0-7)」。
* ZM15.MAN
  * ファンクション`$10xx M_EFCT_OUT`の「ファンクション$8005」は、正しくは「ファンクション$8006」。

## ZMSC3LIB Version 0.01

* ZMCHECKZMSC.HAS `zm_check_zmsc()`: スーパーバイザモードで呼び出すとアドレスエラーが発生する。
  * スーパーバイザになるための`IOCS _B_SUPER`の返り値を見てユーザーモードに戻るための`_B_SUPER`
    を省略しなければならないが、その処理が抜けているため。
  * X-BASIC用外部関数MUSICZ3.FNCのライブラリ版という位置付けのため、もともとスーパーバイザモード
    を想定していないのかも。
* ZMADPCM1.HAS `zm_se_adpcm1()`: スタックに積まれた引数を正しく受け取れず、正しく動作しない。
  * `move.b param2(sp),d1`ではなく`move.b param2+3(sp),d1`のように読み込む必要がある。
* ZMADPCM2.HAS `zm_se_adpcm2()`: スタックに積まれた引数を正しく受け取れず、正しく動作しない。
* ZM_ATOI.HAS `zm_atoi()`: `ZM_STOP`ファンクションが呼ばれているため、正しく動作しない。
* ZMPCMREAD.HAS `zm_pcm_read()`: `char *param`引数が無視され、`a1`レジスタが不定なため
  正しく動作しない。エラー時に0以外の値が返る。

