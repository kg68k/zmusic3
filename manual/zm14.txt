
	    ＭＥＡＳＵＲＥ１４

      効果音モードと外部プログラムとの同期





  ここでは、ＺＭＵＳＩＣの特殊機能である

｢効果音モード｣と｢外部プログラムとの同期｣に

ついての解説を行います。本章を理解するには

MPU680x0の機械語の知識が必要です。

  通常の音楽演奏のみを行なうユーザーは読み

飛ばして構いません。

  ｢効果音モード｣の解説はオリジナル

ゲームプログラムで実際に使用することを想

定して具体的に解説します。








１４．１．  効果音モード


１４．１．１．  ＺＭＳＣ３．Ｘの組み込み


１４．１．１．１．効果音トラックの確保


　効果音モードを利用するにはZMSC3.Xを常駐させる時に、コマンドオプション'-F'を

設定し、効果音用のトラックを確保しなければならない。効果音用のトラックを確保

しない場合、ZMDを利用した効果音の演奏は一切行えない。
-------------------------------------------------------------------------------
－Ｆn

      効果音モード用にトラックをn本確保する。効果音モードを利用する時は

　　nに1～65534を設定する。デフォルトではn=0で｢効果音モードを利用しない｣

　　設定となる。効果音トラックに何トラック割り当てても音楽演奏のトラック数の

　　最大数には影響無い。

  例

	A>ZMSC3 -F4	(効果音トラックに4トラック確保)
-------------------------------------------------------------------------------


１４．１．１．２．組み込みメッセージの制御


  ZMSC3.Xを組み込んだ後にZMUSICのロゴやバージョン番号、確保したバッファの

容量等の情報が画面に出力される。このスイッチを設定するとこれらを一切表示

しないようにすることができる。アプリケーションを起動する際の画面バランスに

気を使う場合は設定するとよい。
-------------------------------------------------------------------------------
－Ｇ

    ＺＭＳＣ３．Ｘ起動時のロゴ表示や常駐を報告するメッセージを表示しない。
-------------------------------------------------------------------------------


１４．１．１．３．初期化処理の制御


  ＺＭＵＳＩＣでは通常、新たに演奏データを演奏する際、MIDI機器に初期化

メッセージを送信したりFM音源、ADPCM音源の初期化処理を実行している。この初期化

処理は新たに演奏する曲の都合を無視したものであり、かなり余計な処理を含んでい

る。たとえばMIDI音源の10以下(1～10)のチャンネルしか使用していない曲を

演奏しようという時も11以上(11～16)のチャンネルの初期化メッセージも送信してしま

う。これはゲームなどのBGMの切り替え時においてゲーム画面のスクロールの一時停止

といった目に見える症状になってしまう場合がある。

  ZMSC3.X常駐時に'-N’オプションを設定すると、以後この初期化処理を必要最低限に

省略することができる。ただし全デバイスに対して、初期化メッセージ送信処理を

省いてしまうため、演奏データ(ZMD)側に必要な初期化メッセージを盛り込む必要が

出てくる（後述）。
-------------------------------------------------------------------------------
－Ｎ

    初期化処理を簡略化する。この設定を行ってZMSC3.Xを常駐させると以後、

  演奏開始時に最低限の初期化処理しか行わなくなる。ゲームなどのBGMを

　機械語レベルで演奏制御する場合に、曲の変り目の処理を軽くする事が出来る。

  通常は設定する必要はない。
-------------------------------------------------------------------------------


１４．１．１．４．ＺＰＤの組み込み


  ゲームなどにおいて、用いるすべてのADPCM音が１つのＺＰＤを用いてる場合は

'-Z'オプションを指定してZMSC3.X常駐時に組み込んでしまうとよい。
-------------------------------------------------------------------------------
－Ｚfilename

    filenameで与えられるADPCM BLOCK DATA｢ZPD｣をZMSC3.X常駐時に読み込む。

  ファイル名拡張子を省略すると自動的に'.ZPD'が添付される。

　例

	A>ZMSC3.X -Zstandard.zpd
-------------------------------------------------------------------------------


１４．１．２．  ゲームプログラムに負担をかけない演奏データとは？


  演奏データ制作者はゲームプログラムに負担をかけないように心掛けて演奏データを

作成するよう留意すべきである。また、曲の切り替りに時間がかからないように工夫

しないと、ゲームの進行を一瞬停止させてしまう恐れがある。

  例えばスクロールシューティングゲームでステージBGMからボス登場のBGMに切り替る

時に、スクロールが一瞬停止してしまってはスピード感を損ねてしまう。

　そこで、まず大前提となるのは利用する演奏データ形式はZMDにべきであるという

点。ZMSでは演奏毎にコンパイラを呼び出してZMDへ変換する必要があるため、

ゲームプログラムへの負担は免れないからだ。

  ここでは、ゲームプログラムに負担をかけないZMDの作成方法、曲の切り換えを

できるだけ早く行えるZMDの作成方法についてのべる。


１４．１．２．１．ZMSコマンドは極力使わない


  ＦＭ音源音色の定義コマンドやMIDIエクスクルーシブメッセージ送信コマンドなどの

トラックに依存しない、いわゆる｢共通コマンド(ZMSコマンド)｣は割り込みで処理され

ないために実行にはある程度のまとまった時間を要する。したがって、曲の切り替え時

などにウェイトになってしまう可能性がある。そこでゲームのBGMにはなるべくZMSコマ

ンドは用いないほうがよい。

  MMLコマンドは割り込み処理されるので、ゲームプログラムの実行を完全に止めて

しまうことはない。そのため、もしMMLに置き換えられるならばZMSコマンドは

用いずに、MMLで代用したほうがよい。たとえば、ZMSコマンド


	.ROLAND_EXCLUSIVE
	(Xn1,n2,n3,…,ni)

などはMMLの

	X
	@X

に置き換えられる。

  どうしても置き換わらない

	     FM音源音色登録

などは後述する方法で解決する。

  なお、曲データである以上必要最低限となるものとして、チャンネルアサイン

ZMSコマンド

(A dev,trk,trkv,trkf,trks,trkm,cmnt)
.ASSIGN trk {dev,trkv,trkf,trks,trkm,cmnt}

があるが、これはコンパイル時に消化されてZMDには出力されないので、用いても

ゲームプログラム側の負担にはならない。


１４．１．２．２．音色登録


  演奏データには様々な音色が使用されるが、この音色データを１曲ごとに持たせて

演奏の開始時にいちいちZMUSICや音源側に登録していたのでは曲の切り替りが遅くなっ

てしまう（アクションゲームのような極端な高速切り替えが要求されていない、ＲＰＧ

やアドベンチャーゲームなら別に構わないであろうが）。

  ZMUSICではFM音源32768音色分(No.1～No.32768)の専用バッファを持っており、

ZMSC3.Xが解除されたりしなければ、この領域はいつまでも保存されている。よって、

そのゲーム中に使用されるFM音源音色をあらかじめZMD化しておき、これをZMSC3.X

常駐時にオプション'-S'を用いて設定してしまい、その後演奏させる演奏データ側には

一切FM音源音色データを持たせずに、あらかじめ登録した音色のみを使用するよう

にすれば、演奏毎の音色登録動作を省くことが出来る。また効果音データで用いる

FM音源音色も一緒に設定してしまうとよいだろう。

  MIDI楽器の音色についてもFM音源音色の場合と同様である。そのゲームの

BGMで使用する音色データをあらかじめMIDI楽器へ送信してしまえばよい

(なんらかの初期化メッセージを受信すると設定した音色までも初期化してしまう

機種もあるので注意)。

  音色のセットアップZMSファイルの例をリスト１に示す。このリスト１のような

ものをZMC.XでコンパイルしてZMD化しておき、

A>ZMSC3.X  －sSETUP.ZMD

のようにしてZMSC3.X常駐とともに組み込んでしまえばよい。

  複数のMIDI楽器に対応している場合はＭＵＳＩＣコンフィギュレーションの

ような場所で楽器機種をユーザーに選ばせ、その時点であらかじめ用意しておいた

その楽器の音色データを転送するようにすればよいだろう。

			リスト1
-------------------------------------------------------------------------------
/		効果音ＦＭ音色データ
(v1,0							/自機ミサイル
/	 AF  OM  WF  SY  SP PMD AMD PMS AMS PAN
	 60, 15,  0,  0,  0,  0,  0,  0,  0,  3,  0
/	 AR  DR  SR  RR  SL  OL  KS  ML DT1 DT2 AME
	 27, 15,  5,  2,  0,  0,  0,  0,  3,  1,  0
	 31, 18, 18,  6,  7,  0,  0,  0,  3,  2,  0
	 22, 31,  0, 10,  0, 42,  0,  7,  7,  0,  0
	 15, 31,  0,  8,  0,  0,  2,  1,  7,  0,  0)
			:
			:
			:
			:

(v20,0							/敵レーザー
/	 AF  OM  WF  SY  SP PMD AMD PMS AMS PAN
	 58, 15,  0,  0,  0,  0,  0,  0,  0,  3,  0
/	 AR  DR  SR  RR  SL  OL  KS  ML DT1 DT2 AME
	 12,  5,  1,  5,  5, 24,  1,  0,  0,  1,  0
	 16,  4,  1,  5,  2, 30,  1,  0,  3,  0,  0
	 29,  6,  5,  5,  2, 16,  2,  0,  3,  2,  0
	  9,  4, 31,  8, 10,  0,  2,  4,  3,  1,  0)

/		楽器ＦＭ音色データ

/	AR 1DR 2DR  RR 1DL  TL  RS MUL DT1 DT2 AME   BASS 1
(@30,	21,  0,  0,  0,  1, 20,  1,  0,  7,  0,  0
	21,  0,  0,  4,  0,  0,  1,  1,  7,  0,  0
	21,  0,  0,  0,  0, 20,  1,  0,  3,  0,  0
	21,  0,  0,  4,  0,  5,  1,  1,  3,  0,  0
/	AL  FB  OM
	 4,  5, 15)

			:
			:
			:
			:

/	AR 1DR 2DR  RR 1DL  TL  RS MUL DT1 DT2 AME   BRASS1
(@100,	19, 17,  0,  8,  1, 24,  1,  1,  1,  0,  0
	19, 13,  0,  8, 15, 37,  1,  2,  0,  0,  0
	19, 17,  0,  8,  1, 36,  1,  1,  0,  0,  0
	19,  4,  5,  8,  2,  0,  1,  1,  2,  0,  0
/	AL  FB  OM
	 2,  7, 15)
/----------------------------------------------------------
/ 		ＭＩＤＩ楽器音色

/       Chord (Saw&Squ)

.roland_exclusive 16,22 ={8,0,0
         67, 72, 79, 82, 68, 32, 32, 32, 32, 32
          0,  0,  3,  0
/ ** PARTIAL1 **
         36, 53, 11,  1,  2,  0, 36,  9
          0,  0,  0,  0,  0,  0,  0, 50, 50, 50, 50, 50
         62, 23, 85
        100, 23,  4, 39,  8, 24
        100,  0,  0,  0, 13, 24, 77, 83,100, 89, 76, 72
         94, 74, 91, 12, 27, 12
          0,  0,  0,  0,  0,  9, 43,100,100,100, 99
/ ** PARTIAL2 **
         36, 48, 11,  1,  3,  0,  0,  0
          0,  0,  0,  0,  0,  0,  0, 50, 50, 50, 50, 50
         64, 23, 56
        100, 23,  5,103,  6, 43
        100,  0,  0,  0,  7, 22,100, 98,100, 94, 84, 79
         94, 70, 91, 12, 27, 12
          0,  0,  0,  4, 11, 14, 15,100, 96, 92, 91}

.mt32_patch 1,16 ={2,0,24,52,2,0,1}

/-----------------------------
/       Keyboard (Harpsichord)

.roland_exclusive 16,22 ={8,4,0
         72, 65, 82, 80, 83, 73, 67, 79, 82, 68
          2,  5,  3,  0
/ ** PARTIAL1 **
         36, 46, 16,  1,  0, 43,  0,  7
          0,  0,  0,  0,  0,  0,  0, 50, 50, 50, 50, 50
          0,  0,  0
          0,  0,  3,  0,  7,  0
          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
         87, 77, 91,  6, 27, 12
          3,  0,  0, 23, 60, 83,  0,100, 88, 88, 88
/ ** PARTIAL2 **
         48, 51, 16,  1,  2,  0,100,  7
          0,  0,  0,  0,  0,  0,  0, 50, 50, 50, 50, 50
          0,  0,  0
        100, 16,  9,103,  8,  0
          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
        100, 75, 27, 12, 15,  5
          1,  1,  0, 23, 60, 92,  0,100, 88, 88, 88}

.mt32_patch 2,16 ={2,2,24,50,2,0,1}

			:
			:
			:
			:
-------------------------------------------------------------------------------


１４．１．２．３．コメント


  演奏データのタイトルや作者名を記述するのに使われている.comment文も演奏時には

文字列をスキップする動作を強いられるため、これがウェイトになりかねないので

用いないようにする。


１４．１．２．４．初期化


  14.1.1.3.で解説したように、ZMSC3.Xを'-N'オプションを付けて初期化処理簡略

モードで常駐させている場合、各演奏データに音源初期化等の設定を盛り込まないと、

音源は前に演奏していた演奏データの設定状態のまま次の曲を演奏してしまう。

  ZMUSICでは、初期化簡略モードでない通常モードの場合、新たな演奏データの

演奏開始直前に以下のような処理を行っている。
-------------------------------------------------------------------------------
●FM音源部

	ノイズモードオフ(Ｙ15,0相当)
-------------------------------------------------------------------------------
●ADPCM音源

	ADPCMのパンポット、再生周波数の初期化
-------------------------------------------------------------------------------
●MIDI音源部

	リセット　オール　コントローラーズ($Bn,$79,$00)

	オムニ  モード  オン($Bn,$7D,$00)

	モノ  モード  オフ($Bn,$7F,$00)

	ローカル  オン($Bn,$7A,$7F)

	ファインチューニングをニュートラルへ($Bn,$65,$00,$Bn,$64,$01,
					     $Bn,$06,$40,$Bn,$26,$00)

	コースチューニングをニュートラルへ($Bn,$65,$00,$Bn,$64,$02,$Bn,$06,$40)

	ピッチ・ベンドレンジ＝１オクターブ($Bn,$65,$00,$Bn,$64,$00,$Bn,$06,$0C)

	ボリューム＝63($Bn,$07,$3F)

	パンポット＝中央($Bn,$0A,$40))

	ピッチ・モジュレーション＝0($Bn,$01,$00)

	ダンパー  オフ($Bn,$40,00)

	ピッチ・ベンドをニュートラルへ($En,$00,$40)

	※nはMIDIチャンネル内部表現($00-$0F)
-------------------------------------------------------------------------------
  初期化なしモードとそうでない場合の違いは、これらの初期化動作が行われるか

行われないかの違いになってくる。

  演奏データをゲームプログラムなどに取り込む前に一度、初期化簡略モードで

演奏してみるとよいだろう。それで演奏がおかしかったならば、どの初期化処理

が足りなかったのかを見極め、上で示した初期化処理を１つずつピックアップして

盛り込んでいくとよいだろう。

  こうしてみるとFM音源とADPCM音源は初期化なしモードと通常モードの区別を特に

意識する必要はないかもしれない。

  ところで、MIDI楽器の場合、ローランド系のDTM楽器（CM/SCシリーズなど）では

楽器の特定のメモリアドレスにダミーデータを書き込むと本体内の全パートを

初期化してくれる便利な機能を持っている。これを使えば上のような初期化メッセージ

をすべて送らなくても少ない手間で初期化が行える。いくつか例を挙げておく。

（初期化したあとの楽器の状態については各楽器マニュアルを参照し確認すること）

●MT32/CM32L/CM64/CM32P/CM500のＬＡ音源部の場合

$7F,$00,$00にダミーデータを書き込む

例

  共通コマンド….ROLAND_EXCLUSIVE $10,$16＝{$7F,$00,$00,$00}

  MML…@I$41,$10,$16 X$7F,$00,$00,$00

●GS音源系の場合

$40,$00,$7Fにダミーデータを書き込む

例

  共通コマンド….ROLAND_EXCLUSIVE $10,$42＝{$40,$00,$7F,$00}

  MML…@I$41,$10,$42 X$40,$00,$7F,$00

  (GS音源はこの方法で初期化するとベンドレンジが2半音とされてしまう点に注意)


１４．１．３．  演奏開始ルーチン


  演奏データ(ZMD)をゲームのメインプログラムから演奏するためには、簡単な演奏

マネージメント・プログラム(つまりは演奏開始ルーチン)が必要となる。さまざまな

演奏開始ルーチンが考えられるがサンプルとしてリスト２を示す。

  この例では各演奏データがmusic0、music1、music2…とそれぞれ偶数番地に

読み込まれているとする。そこでmusic0を演奏したいならばd0.lに0、music1を

演奏したいならばd0.lに1を入れ、このルーチンplay_musicをサブルーチンコールする

ようにする。これで演奏が開始される。

  ZMDの演奏にはZMUSIC Ver.3.0のファンクションZM_PLAY_ZMDを利用するが、この

ファンクションの｢a1.lは演奏データの先頭8バイトヘッダの次のアドレスを指して

いなければならない｣という仕様から演奏データテーブルの各要素には +8 が

加算してある点に注意。詳しくはファンクションZM_PLAY_ZMDの項を参照。

			リスト2
-------------------------------------------------------------------------------
	include	zmcall.mac

Z_MUSIC	macro	func		*ZMUSICへのファンクションコール
	moveq.l	func,d0
	trap	#3
	endm

play_music:
	* < d0.l=曲番号(0～16383)
	movem.l	d0-d2/a0-a1,-(sp)
	add.l	d0,d0
	add.l	d0,d0
	movea.l	music_data_tbl(pc,d0.l),a1
	moveq.l	#0,d2				*高速応答モード
	Z_MUSIC	#ZM_PLAY_ZMD
	movem.l	(sp)+,d0-d2/a0-a1
	rts

music_data_tbl:
	dc.l	music0+8
	dc.l	music1+8
	dc.l	music2+8
	dc.l	music3+8
	dc.l	music4+8
	dc.l	music5+8
	dc.l	music6+8
	dc.l	music7+8
		:
		:
		:
		:
-------------------------------------------------------------------------------


１４．１．４．効果音データの作成とその活用方法


  ZMUSIC Ver.2.0以前では、効果音を演奏させるには、音楽演奏データ側のトラックと

チャンネルの関係を把握しておかなければならなかったが、Ver.3.0では音楽データと

効果音データの演奏はそれぞれ独立した処理系で演奏されるため、特に前準備は必要

としなくなっている。FM音源の音楽を演奏中にFM音源の効果音を演奏させても、チャン

ネル間の競合はZMUSIC側で処理するため、音楽演奏、効果音演奏、双方とも任意の

チャンネルを割り当てることが出来る。

  また、テンポに関しても音楽側と効果音側で独立したテンポを設定することが出来

るようになった。

　ここでは、効果音データの作成方法とその演奏方法について解説する。


１４．１．４．１．効果音データ


  効果音データは

1.完全な音楽データと同様の形態をとるもの

2.演奏データトラックのみで構成されるもの

の2通りがある。

　1.のタイプは共通コマンド(ZMSコマンド)までも含んだ完全なZMDファイルで、通常の

ZMSをコンパイラでZMD化したものに相当する。2.のタイプは前者から演奏データ部分

だけを分離したものである。

　1.のタイプの演奏はリスト2のZM_PLAY_ZMDをZM_PLAY_ZMD_SEにした流用ルーチンが

利用出来る。ただし、1.のタイプの演奏には共通コマンド部分の実行などの手間が

はいるため、効果音演奏まで一瞬のタイムラグが発生する可能性がある。そのため

高速応答が要求されるアクションゲームの効果音には向かない。

  2.のタイプはZMDのトラック・チャンネル情報テーブル(MEASURE12参照)と実際の

トラック演奏データで構成される。こちらの効果音データの作成方法を以下に示す。

　まず、リスト3のようなZMSがあったとする。

			リスト3
-------------------------------------------------------------------------------
(v12,0						/音色データは事前に登録しておく
/	 AF  OM  WF  SY  SP PMD AMD PMS AMS PAN
	 59, 15,  0,  0,  0,  0,  0,  0,  0,  3,  0
/	 AR  DR  SR  RR  SL  OL  KS  ML DT1 DT2 AME
	 23,  8,  1,  8,  7, 31,  2,  1,  5,  3,  0
	 30,  8,  8,  7,  5, 20,  1,  2,  1,  2,  0
	 22,  3,  7,  8,  1, 20,  1,  1,  3,  0,  0
	 27,  0,  0,  9,  0,  0,  1,  2,  5,  1,  0)

(i)
.assign TR1 {FM8}
(t1)@12 o3 q8 v14 p3 @k0 @m60 @h24 @s3 (a16<a)&a4.&(a16>a)
(p)
-------------------------------------------------------------------------------

  これをコンパイルしてZMD化するとリスト4のようになる。

			リスト4
-------------------------------------------------------------------------------
00000000  1A 5A 6D 75 53 69 63 30 00 00 00 44 00 00 00 76 .ZmuSic0...D...v
00000010  00 00 00 00 00 00 00 D4 00 00 00 00 00 00 00 00 .......ﾔ........
00000020  00 00 00 00 00 00 00 00 00 00 00 60 00 00 00 00 ...........`....
00000030  00 00 00 00 00 00 00 C0 00 78 00 00 00 00 00 41 .......ﾀ.x.....A
00000040  00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 ................
00000050  18 00 0B 00 00 80 00 78 FB 00 51 31 12 52 1F 14 .....  x..Q1.R..
00000060  14 00 97 56 5E 5B 08 03 08 00 C1 07 88 40 78 18 ..遊^[....ﾁ..@x.
00000070  57 09 20 20 20 20 20 20 20 20 20 20 20 20 20 20 W.              
00000080  20 20 00 00 FF FF 00 00 00 00 00 00 00 00 00 07   ..............
00000090  00 00 00 14 00 00 00 00 00 00 00 00 00 00 00 00 ................
000000A0  00 00 00 00 00 00 00 00 C7 00 0B 90 8E A0 40 B9 ........ﾇ..錘@ｹ
000000B0  00 00 E2 01 01 00 3C E4 00 01 00 18 E3 01 00 06 ......<.........
000000C0  84 39 45 0C 80 00 80 45 48 80 00 80 84 45 39 0C .9E.  E H  ・E9.
000000D0  0C 80 FF FF                                     . .
-------------------------------------------------------------------------------

トラック・チャンネル情報テーブルはオフセットz_trk_offset(MEASURE12参照)で表

される位置あるので、リスト4の場合は

	$00000076+$10=$00000086

先頭から$00000086のところにあることになる。2.の方式の効果音データではこれより

前のデータが不要であるため削除してしまう。これがリスト5である。

			リスト5
-------------------------------------------------------------------------------
00000000  
00000010  
00000020  
00000030  			削除してしまう
00000040  
00000050  
00000060  
00000070  
00000080                    00 00 00 00 00 00 00 00 00 07   ..............
00000090  00 00 00 14 00 00 00 00 00 00 00 00 00 00 00 00 ................
000000A0  00 00 00 00 00 00 00 00 C7 00 0B 90 8E A0 40 B9 ........ﾇ..錘@ｹ
000000B0  00 00 E2 01 01 00 3C E4 00 01 00 18 E3 01 00 06 ......<.........
000000C0  84 39 45 0C 80 00 80 45 48 80 00 80 84 45 39 0C .9E.  E H  ・E9.
000000D0  0C 80 FF FF                                     . .
-------------------------------------------------------------------------------
　これをプログラムソース形式に変換したものが、リスト6。これには参考までに

トラック・チャンネル情報テーブルのキャプションを添付してある。

				リスト6
-------------------------------------------------------------------------------
	.dc.b	$00,$00			*ti_n_of_tracks(演奏トラック数-1)
	.dc.b	$00			*ti_track_stat
	.dc.b	$00			*ti_track_mode
	.dc.b	$00			*ti_trkfrq
	.dc.b	$00			*dummy
	.dc.b	$00,$00			*ti_type(デバイスタイプ:0,1,$8000～$8003)
	.dc.b	$00,$07			*ti_ch(チャンネル番号:0-15)
	.dc.b	$00,$00,$00,$14		*ti_play_data(演奏データまでのオフセットアドレス)
	.dc.b	$00,$00,$00,$00		*ti_extra_info(トラック追加情報までのオフセット)
	.dc.b	$00,$00,$00,$00,$00,$00,$00,$00
	.dc.b	$00,$00,$00,$00,$00,$00,$00,$00
	.dc.b	$c7,$00,$0b,$90,$8e,$a0,$40,$b9	*演奏データ
	.dc.b	$00,$00,$e2,$01,$01,$00,$3c,$e4
	.dc.b	$00,$01,$00,$18,$e3,$01,$00,$06
	.dc.b	$84,$39,$45,$0c,$80,$00,$80,$45
	.dc.b	$48,$80,$00,$80,$84,$45,$39,$0c
	.dc.b	$0c,$80,$ff,$ff
-------------------------------------------------------------------------------

  リスト7のように複数トラックで構成される効果音データも同様にして作成可能で

ある。これをコンパイルし同様の手続きにて変換してやるとリスト8のようになる。

				リスト7
-------------------------------------------------------------------------------
(i)
.assign tr1 {FM7}
.assign tr2 {FM8}
(t1)@7 o7 q8 v15 p3 @k0 @l1e<g>>cd<<e>(f8<f)p0
(t2)@4 o7 q8 v12 p3 @k0 L32(c>c)&(c<e)r1
(p)
-------------------------------------------------------------------------------

				リスト8
-------------------------------------------------------------------------------
	.dc.b	$00,$01			*ti_n_of_tracks(演奏トラック数-1)
	.dc.b	$00			*ti_track_stat
	.dc.b	$00			*ti_track_mode
	.dc.b	$00			*ti_trkfrq
	.dc.b	$00			*dummy
	.dc.b	$00,$00			*ti_type(デバイスタイプ:0,1,$8000～$8003)
	.dc.b	$00,$06			*ti_ch(チャンネル番号:0-15)
	.dc.b	$00,$00,$00,$24		*ti_play_data(演奏データまでのオフセットアドレス)
	.dc.b	$00,$00,$00,$10		*ti_extra_info(トラック追加情報までのオフセット)
	.dc.b	$00			*ti_track_stat
	.dc.b	$00			*ti_track_mode
	.dc.b	$00			*ti_trkfrq
	.dc.b	$00			*dummy
	.dc.b	$00,$00			*ti_type(デバイスタイプ:0,1,$8000～$8003)
	.dc.b	$00,$07			*ti_ch(チャンネル番号:0-15)
	.dc.b	$00,$00,$00,$4c		*ti_play_data(演奏データまでのオフセットアドレス)
	.dc.b	$00,$00,$00,$38		*ti_extra_info(トラック追加情報までのオフセット)
	.dc.b	$00,$00,$00,$00,$00,$00,$00,$00
	.dc.b	$00,$00,$00,$00,$00,$00,$00,$00
	.dc.b	$c7,$00,$06,$90,$8f,$a0,$40,$b9	*第1トラックの演奏データ
	.dc.b	$00,$00,$64,$01,$01,$80,$73,$01
	.dc.b	$01,$80,$54,$01,$01,$80,$56,$01
	.dc.b	$01,$80,$70,$01,$01,$80,$84,$65
	.dc.b	$71,$18,$18,$80,$a0,$80,$ff,$ff
	.dc.b	$00,$00,$00,$00,$00,$00,$00,$00
	.dc.b	$00,$00,$00,$00,$00,$00,$00,$00
	.dc.b	$c7,$00,$03,$90,$8c,$a0,$40,$b9	*第2トラックの演奏データ
	.dc.b	$00,$00,$84,$60,$54,$06,$80,$00
	.dc.b	$80,$84,$54,$64,$06,$06,$80,$80
	.dc.b	$80,$c0,$80,$c0,$ff,$ff,$ff,$ff
-------------------------------------------------------------------------------


１４．１．４．２．効果音演奏形式


  効果音を鳴らす場合には２通りの形式が存在する。

  １つは効果音が鳴るチャンネルをあらかじめ空けておく形式である。つまり効果音を

演奏するチャンネルをあらかじめ決めておき音楽(BGM)側のデータを作成するわけで

ある。たとえばFM音源の１チャンネルから７チャンネルまでをBGM専用チャンネルとし、

８チャンネル目を効果音チャンネルと割り当てる。

  ２つ目はBGMを演奏しているチャンネルに割り込んで効果音を演奏する形式である。

たとえばFM音源の１から８チャンネルすべてのチャンネルでBGMを演奏し、そのうち

８チャンネルが効果音に切り換わったりする、という場合である。この場合では、

効果音が頻繁に演奏されると８チャンネル目はほとんど効果音しか鳴らなくなって

しまいBGMの一声分が欠けて聞こえることになる。よってBGMの作成設計をする際には、

効果音が被ってくるチャンネルにはメロディやベース等の重要なパートを割り当て

ないようにすべきである。


１４．１．４．３．効果音の演奏


  リスト9は効果音のマネージメント・プログラムの一例である（リスト9中の

サンプル効果音は、それぞれリスト6、リスト8とまったく同じもの)。

  リスト9中のse_play1はd0.lに鳴らしたい効果音番号を代入して呼び出すと対応する

効果音が演奏されるルーチンである。

				リスト9
-------------------------------------------------------------------------------
	.include	zmcall.mac

Z_MUSIC	macro	func		*ZMUSICへのファンクションコール
	moveq.l	func,d0
	trap	#3
	endm

se_play1:
	* < d0.l=sound number(0-32767)
	* - all
	movem.l	d0-d1/a0-a1,-(sp)
	add.w	d0,d0
	move.w	se_tbl(pc,d0.w),d0
	lea	se_tbl(pc,d0.w),a1
	Z_MUSIC	#ZM_SE_PLAY
	movem.l	(sp)+,d0-d1/a0-a1
	rts

se_play2:
	* < d0.l=sound number
	* < d1.l=ch number
	* - all
	movem.l	d0-d2/a0-a1,-(sp)
	add.w	d0,d0
	move.w	se_tbl(pc,d0.w),d0
	lea	se_tbl(pc,d0.w),a1
	moveq.l	#0,d2
	move.w	(a1),d0
@@:
	move.l	d1,6(a1,d2.l)	*デバイス・チャンネルセット
	addq.w	#1,d1		*チャンネルのオーバーフローはノーチェック
	add.l	#16,d2
	dbra	d0,@b
	Z_MUSIC	#ZM_SE_PLAY
	movem.l	(sp)+,d0-d2/a0-a1
	rts

se_tbl:
	dc.w	se0-se_tbl		*$00
	dc.w	se1-se_tbl		*$01
	dc.w	se2-se_tbl		*$02
	dc.w	se3-se_tbl		*$03
	dc.w	se4-se_tbl		*$04
			:
			:
			:

se0:
	.dc.b	$00,$00			*ti_n_of_tracks(演奏トラック数-1)
	.dc.b	$00			*ti_track_stat
	.dc.b	$00			*ti_track_mode
	.dc.b	$00			*ti_trkfrq
	.dc.b	$00			*dummy
	.dc.b	$00,$00			*ti_type(デバイスタイプ:0,1,$8000～$8003)
	.dc.b	$00,$07			*ti_ch(チャンネル番号:0-15)
	.dc.b	$00,$00,$00,$14		*ti_play_data(演奏データまでのオフセットアドレス)
	.dc.b	$00,$00,$00,$00		*ti_extra_info(トラック追加情報までのオフセット)
	.dc.b	$00,$00,$00,$00,$00,$00,$00,$00
	.dc.b	$00,$00,$00,$00,$00,$00,$00,$00
	.dc.b	$c7,$00,$0b,$90,$8e,$a0,$40,$b9	*演奏データ
	.dc.b	$00,$00,$e2,$01,$01,$00,$3c,$e4
	.dc.b	$00,$01,$00,$18,$e3,$01,$00,$06
	.dc.b	$84,$39,$45,$0c,$80,$00,$80,$45
	.dc.b	$48,$80,$00,$80,$84,$45,$39,$0c
	.dc.b	$0c,$80,$ff,$ff
	.even
se1:
	.dc.b	$00,$01			*ti_n_of_tracks(演奏トラック数-1)
	.dc.b	$00			*ti_track_stat
	.dc.b	$00			*ti_track_mode
	.dc.b	$00			*ti_trkfrq
	.dc.b	$00			*dummy
	.dc.b	$00,$00			*ti_type(デバイスタイプ:0,1,$8000～$8003)
	.dc.b	$00,$06			*ti_ch(チャンネル番号:0-15)
	.dc.b	$00,$00,$00,$24		*ti_play_data(演奏データまでのオフセットアドレス)
	.dc.b	$00,$00,$00,$10		*ti_extra_info(トラック追加情報までのオフセット)
	.dc.b	$00			*ti_track_stat
	.dc.b	$00			*ti_track_mode
	.dc.b	$00			*ti_trkfrq
	.dc.b	$00			*dummy
	.dc.b	$00,$00			*ti_type(デバイスタイプ:0,1,$8000～$8003)
	.dc.b	$00,$07			*ti_ch(チャンネル番号:0-15)
	.dc.b	$00,$00,$00,$4c		*ti_play_data(演奏データまでのオフセットアドレス)
	.dc.b	$00,$00,$00,$38		*ti_extra_info(トラック追加情報までのオフセット)
	.dc.b	$00,$00,$00,$00,$00,$00,$00,$00
	.dc.b	$00,$00,$00,$00,$00,$00,$00,$00
	.dc.b	$c7,$00,$06,$90,$8f,$a0,$40,$b9	*第1トラックの演奏データ
	.dc.b	$00,$00,$64,$01,$01,$80,$73,$01
	.dc.b	$01,$80,$54,$01,$01,$80,$56,$01
	.dc.b	$01,$80,$70,$01,$01,$80,$84,$65
	.dc.b	$71,$18,$18,$80,$a0,$80,$ff,$ff
	.dc.b	$00,$00,$00,$00,$00,$00,$00,$00
	.dc.b	$00,$00,$00,$00,$00,$00,$00,$00
	.dc.b	$c7,$00,$03,$90,$8c,$a0,$40,$b9	*第2トラックの演奏データ
	.dc.b	$00,$00,$84,$60,$54,$06,$80,$00
	.dc.b	$80,$84,$54,$64,$06,$06,$80,$80
	.dc.b	$80,$c0,$80,$c0,$ff,$ff,$ff,$ff
	.even
			:
			:
			:
			:
-------------------------------------------------------------------------------
  se_play1に対してd0.l=0としてコールすると効果音se0がFM音源第8チャンネルで

演奏される。なぜFM音源のチャンネル8かはse0のキャプションti_type,ti_chを

見ればわかる。もし、同内容の効果音を別のチャンネルで演奏したい場合は、

この部分を効果音演奏ルーチン側で書き換えればよい(演奏デバイス、チャンネルを

変えたZMDを別途用意しても構わないが、こちらの方法の方がメモリを節約出来る)。

リスト9のse_play2はその一例である。d0.lに効果音番号、d1.lに演奏デバイス、

チャンネルをパラメータとして与える。se_play2では効果音データのアドレスを得た

あと、そのアドレス+6に演奏デバイス・チャンネルを書き込んでいる。+6という

オフセットはse0の演奏デバイス・チャンネル情報がこの位置にあることからきている

(キャプションti_type,ti_ch)。

  そしてd1.lに代入されている演奏デバイス・チャンネルのチャンネルの方を+1し、

d2.lを+16して、このあとループ制御を行っている。このループ制御によりルーチンは

演奏する効果音の構成トラック数の回数分ループするようになっている。これは効果音

データが複数トラックで構成されている場合に対応した部分である。例えば、se1の

場合ならば｢se1のアドレス+6｣と｢se1のアドレス+22｣に対しても演奏デバイス・

チャンネルを書き込む必要があるが、このループ制御でこれを行わせている。効果音

演奏チャンネルに対して+1しているのは、複数トラックから構成される効果音の各トラ

ックに1ずつ昇順に別々のチャンネルを割り当てる目的で、また、d2.lに対する+16は

次のトラック・チャンネル情報テーブルをポイントする目的でオフセット加算を行って

いる。

  このように効果音のデータを直接書き換える手法を応用するとさまざまな効果を

実現することが出来る。ここで示した例は、演奏デバイス・チャンネルを書き換える

程度のものだが、効果音の演奏データそのものを直接書き換えたりすれば一層応用の

幅が広がる。たとえば3Dゲームならば、効果音の演奏データ部分のパンポットZMDや

音量ZMDのパラメータを、その3次元座標に合せて直接書き替えて演奏させてやれば

疑似立体音響のようなものも実現可能だ。


１４．１．４．４．ADPCM音の効果音


  ADPCM音の効果音も、これまでに解説してきた方法で演奏することが出来るが、

ZMUSIC Ver.3.0ではADPCM効果音専用のファンクションコールが設けてあり、これを

利用することでも演奏させることが出来る。

  リスト10がこれらファンクションを用いたマネージメントプログラムの一例である。

				リスト10
-------------------------------------------------------------------------------
	.include	zmcall.mac

Z_MUSIC	macro	func		*ZMUSICへのファンクションコール
	moveq.l	func,d0
	trap	#3
	endm

ADPCM_se_play1:					*ADPCM効果音
	*任意のアドレスに格納されたADPCM音を効果音として鳴らす
	*
	* < d0.l=効果音番号
	*
	movem.l	d0-d2/d4/a0-a1,-(sp)
	lsl.l	#3,d0
	movem.l	adpcm_se_tbl1(pc,d0.w),d1-d2/d4/a1
	Z_MUSIC	#ZM_SE_ADPCM1
	movem.l	(sp)+,d0-d2/d4/a0-a1
	rts

adpcm_se_tbl1:
	*0  データ種類(.b)(MPCM.X常駐時のみ有効)	-1:ADPCM,1:16bitPCM,2:8bitPCM
	*1  音量(.b)(MPCM.X常駐時のみ有効)		0～127(64が原音量)
	*2  パンポット(.b)				1:左 2:右 3:中央 または $80+(0～127)
	*3  再生周波数(.b)				0～4
	*4  データのサイズ(.l)
	*8  優先レベル(.w)				0～255 (0が一番低い)
	*10 演奏チャンネル(.w)(MPCM.X常駐時のみ有効)	0～15
	*12 データアドレス(.l)

	dc.l	$ff_40_02_03,$0000_000f,2212,adpcm_se0
	dc.l	$ff_40_04_03,$0001_000f,3478,adpcm_se1
	dc.l	$ff_40_03_01,$0000_000f,5453,adpcm_se2
	dc.l	$ff_40_04_02,$0001_000f,1401,adpcm_se3
	dc.l	$ff_40_04_03,$0000_000f,8799,adpcm_se4
			:
			:
			:
			:

ADPCM_se_play2:
	*ZMUSICに登録したADPCM音を効果音として鳴らす
	*
	* < d0.l=効果音番号
	*
	movem.l	d0-d2/d4/a0,-(sp)
	lsl.l	#3,d0
	movem.l	adpcm_se_tbl2(pc,d0.w),d1-d2/d4
	Z_MUSIC	#ZM_SE_ADPCM2
	movem.l	(sp)+,d0-d2/d4/a0
	rts

adpcm_se_tbl2:
	*0  データ種類(.b)(MPCM.X常駐時のみ有効)	-1:ADPCM,1:16bitPCM,2:8bitPCM
	*1  音量(.b)(MPCM.X常駐時のみ有効)		0～127(64が原音量)
	*2  パンポット(.b)				1:左 2:右 3:中央 または($80+0～127)
	*3  再生周波数(.b)				0～4
	*4  優先レベル(.w)				0～255 (0が一番低い)
	*6  演奏チャンネル(.w)(MPCM.X常駐時のみ有効)	0～15
	*8  登録トーン/音色番号(.l)			0～32767 または $8000+(0～32767)
	dc.l	$ff_40_02_03,$0000_0007,0,0
	dc.l	$ff_40_04_03,$0001_0007,1,0
	dc.l	$ff_40_03_01,$0000_0007,2,0
	dc.l	$ff_40_04_02,$0001_0007,3,0
	dc.l	$ff_40_04_03,$0000_0007,4,0
			:
			:
			:
			:
-------------------------------------------------------------------------------
  まず、リスト中のADPCM_se_play1について。これは任意のアドレスに格納されている

ADPCMデータをファンクションZM_SE_ADPCM1を使って、BGMに割り込ませて鳴らすための

サブルーチンである。BGM側でADPCMをドラム等で使用している場合はそれを一時停止

して効果音を演奏する。効果音が鳴り終ると自動的にBGMの演奏にもどる。

  ADPCM_se_play1ではアドレスに配置されたADPCMデータに便宜的に番号をつけ、

呼び出す時にはd0.lにその番号を代入して呼び出すようになっている。ルーチン後ろに

あるadpcm_se_tbl1は各効果音ADPCMデータのデータ属性、再生属性、優先レベル

(囲み参照)再生チャンネル、データサイズ、データアドレスなどを列記した管理テー

ブルである。

  ADPCM_se_play2はファンクションコールZM_SE_ADPCM2を用いて、ZMUSIC側にすでに

ZPDとして登録済みのADPCM音を効果音として鳴らすためのサブルーチンである。d0.lに

演奏したい効果音番号を代入してADPCM_se_play2をコールして使用する。ルーチン後ろ

にあるadpcm_se_tbl2はADPCM_se_play1のadpcm_set_tbl1からデータサイズとデータア

ドレスを取り去り、変わりに登録トーン/音色番号を書き込んだものになっている。



┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃                         ADPCM効果音の優先レベル                     	    ┃
┃                                                                          ┃
┃                                                                          ┃
┃  X680x0のADPCMは(MPCM.X非常駐時は)単声仕様です。ですから効果音の発音要求 ┃
┃                                                                          ┃
┃は基本的に後着優先、つまり新しく発音要求されたものが優先的に発音されること┃
┃                                                                          ┃
┃になっています。しかし、ゲームなどで面と面との繋ぎのイベントの音声メッセー┃
┃                                                                          ┃
┃ジなど、どうしても爆発音などでかき消されたくない場合があります。そこで    ┃
┃                                                                          ┃
┃ZMUSIC Ver.3.0ではADPCM効果音を発音させる時に優先レベルというものを設定   ┃
┃                                                                          ┃
┃できるようになっています。優先レベルは0～255で設定可能です。実用上は0,1   ┃
┃                                                                          ┃
┃程度で十分でしょう。   					            ┃
┃                                                                          ┃
┃  以下に優先レベル0,1を用いた例を示します。                               ┃
┃                                                                          ┃
┃  ┌─────────┬──────────┬───────┐            ┃
┃  │発音中の優先レベル│発音要求の優先レベル│     結果     │            ┃
┃  ├─────────┼──────────┼───────┤            ┃
┃  │       0          │        0           │ 発音要求採択 │            ┃
┃  │       0          │        1           │ 発音要求採択 │            ┃
┃  │       1          │        0           │ 発音要求却下 │            ┃
┃  │       1          │        1           │ 発音要求採択 │            ┃
┃  └─────────┴──────────┴───────┘            ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛


１４．２．  外部プログラムとの同期


  ZMUSIC Ver.3.0には外部プログラムと音楽演奏を同期させるためのファンクション

コールや機能が装備されている。ここではこの機能について解説を行う。


１４．２．１． ファンクションZM_OBTAIN_EVENTS


  ファンクションZM_OBTAIN_EVENTSは、ZMUSIC Ver.3.0とユーザープログラムを仲立ち

するファンクションで、ユーザープログラムで設定した条件を満たすと、ZMUSICから

ユーザープログラム側へルーチンの実行が移る仕組みになっている。

			MEASURE10より抜粋
--------------------------------------------------------------------------------
ファンクション$58	ZM_OBTAIN_EVENTS

機能	各種イベントの取得

引数	d1.w:どのイベントに関する設定を行うかのビットマーカー
	     ビット=1でそのイベントの設定を更新する。
	a1.l:各種イベント発生時のジャンプ先とジャンプ条件が
	     記述された領域。構成は備考参照。
	     -1とするとint omtによらず設定は一切行わない。

戻り値	a0.l=現在の設定を格納した領域のアドレス。構成は備考参照。

備考	$00(a1):m_playが実行された時のジャンプ先アドレス		d1.wのd0ビット
	$04(a1):m_stopが実行された時のジャンプ先アドレス		d1.wのd1ビット
	$08(a1):m_contが実行された時のジャンプ先アドレス		d1.wのd2ビット
	$0c(a1):演奏が終了した時のジャンプ先アドレス			d1.wのd3ビット
	$10(a1):指定ループ回数(0:OFF,1-256)				d1.wのd4ビット
	$14(a1):指定回数ループした時のジャンプ先アドレス		d1.wのd5ビット
	$18(a1):指定クロック(0:OFF,1～)					d1.wのd6ビット
	$1c(a1):演奏開始後指定クロック経過した時のジャンプ先アドレス	d1.wのd7ビット

	d1.wでビット=1としたパラメータのみをa1.lから記述しておく。
	d1.wでビット=0としたパラメータに関しては記述しない。
	たとえばd1.w=$81の場合、a1.lからは
	$00(a1)に｢m_playが実行された時のジャンプ先アドレス｣
	$04(a1)に｢演奏開始後指定クロック経過した時のジャンプ先アドレス｣
	を記述しておけばよい。

	なお、各ジャンプ先のルーチンではレジスタを破壊してはならず(保存する
	必要がある)、ルーチンの終端は「RTS」命令で終わる必要がある。
--------------------------------------------------------------------------------
　具体的には

・演奏が終了したら指定アドレスへジャンプ

・演奏開始後、指定クロック(絶対音長)でnカウント経過したら指定のアドレスへ
  ジャンプ

・演奏をx回繰り返したら指定のアドレスへジャンプ

といった、ユーザープログラムとZMUSIC Ver.3.0の連係動作を実現出来る。

　この他、ファンクションZM_OBTAIN_EVENTSには演奏開始｣｢演奏停止｣｢演奏再開｣が

実行された時のイベントをユーザープログラムが取得出来る機能がある。

  以下にファンクションZM_OBTAIN_EVENTSの使用サンプルを示す

			リスト11
--------------------------------------------------------------------------------
	.include	zmcall.mac

Z_MUSIC	macro	func		*ZMUSICへのファンクションコール
	moveq.l	func,d0
	trap	#3
	endm

sample1:
	movem.l	d0-d1/a0-a1,-(sp)
	moveq.l	#$08,d1				*d3ビット=1
	lea	user_event(pc),a1
	Z_MUSIC	#ZM_OBTAIN_EVENTS
	movem.l	(sp)+,d0-d1/a0-a1
	rts

performance_end:
	movem.l	d0-d7/a0-a6,-(sp)
		:
		:
		:
	movem.l	(sp)+,d0-d7/a0-a6
	rts

user_event:
	dc.l	performance_end
--------------------------------------------------------------------------------
　これは演奏中の曲が演奏終了した場合performance_endにジャンプするように設定

している。実際のイベント処理ルーチンはperformance_endから始まるが、上の

サンプルではその内容までは省略している。ただし、サンプルで示しているように

イベント処理ルーチン内で使用するレジスタはすべてそのルーチンエントリで保存し、

終了時に復元しなければならない。また、ルーチンからの帰還には「RTS」を使用し

ている点に注意。割り込み処理とは異なるため「RTE」などを使用してはならない。

　なお、同様にして、指定回数ループ、イベント処理ルーチンへジャンプ(リスト12)、

指定クロック経過後イベント処理ルーチンへジャンプ(リスト13)といったことも

行える。

			リスト12
--------------------------------------------------------------------------------
	.include	zmcall.mac

Z_MUSIC	macro	func		*ZMUSICへのファンクションコール
	moveq.l	func,d0
	trap	#3
	endm

sample2:

	movem.l	d0-d1/a0-a1,-(sp)
	moveq.l	#$30,d1				*d4,d5ビット=1
	lea	user_event(pc),a1
	Z_MUSIC	#ZM_OBTAIN_EVENTS
	movem.l	(sp)+,d0-d1/a0-a1
	rts

loop_completed:
	movem.l	d0-d7/a0-a6,-(sp)
		:
		:
		:
	movem.l	(sp)+,d0-d7/a0-a6
	rts

user_event:
	dc.l	10				*ループ条件
	dc.l	loop_completed
--------------------------------------------------------------------------------

			リスト13
--------------------------------------------------------------------------------
	.include	zmcall.mac

Z_MUSIC	macro	func		*ZMUSICへのファンクションコール
	moveq.l	func,d0
	trap	#3
	endm

sample3:
	movem.l	d0-d1/a0-a1,-(sp)
	moveq.l	#$c0,d1				*d3ビット=1
	lea	user_event(pc),a1
	Z_MUSIC	#ZM_OBTAIN_EVENTS
	movem.l	(sp)+,d0-d1/a0-a1
	rts

n_count_passed:
	movem.l	d0-d7/a0-a6,-(sp)
		:
		:
		:
	movem.l	(sp)+,d0-d7/a0-a6
	rts

user_event:
	dc.l	480				*指定クロック
	dc.l	n_count_passed
--------------------------------------------------------------------------------
　リスト12では10回ループしたらイベント処理ルーチンへ、リスト13では480クロック

経過したらイベント処理ルーチンへ飛ぶようになっている。


１４．２．２．  ユーザー開放ワークを利用する


  ZMUSIC Ver.3.0は演奏が開始されると、音楽演奏割り込み処理が起動されるたびに

汎用ワークzmusic_intがインクリメントされる(音楽割り込み処理の起動は、絶対音長

1毎に発生する)。この値は外部から参照可能であるため、ここを外部プログラムで

監視することで、音楽との同期を実現出来る。

　以下にそのサンプルを示す。

			リスト14
--------------------------------------------------------------------------------
	.include	zmcall.mac
	.include	zm_stat.mac

Z_MUSIC	macro	func		*ZMUSICへのファンクションコール
	moveq.l	func,d0
	trap	#3
	endm

	Z_MUSIC	#ZM_GET_ZMSC_STATUS
	move.l	zmusic_int(a0),d0
	cmpi.l	#xxxx,d0
	bcs	@f
		:
	    条件成立
		:
@@:
	rts
--------------------------------------------------------------------------------
　ファンクションZM_GET_ZMSC_STATUSはZMUSIC Ver.3.0の汎用ワークのベースアドレス

を得るファンクションで、a0.lにそのアドレスを返す(ソースリストアーカイヴに

含まれるzm_stat.macをインクルードすることにより、各ワークをオフセット名で

指定することが出来る)。

　zmusic_intの内容を目的の経過クロックと比較して、もし指定クロックを過ぎていた

ならば「条件成立」内を実行する。


１４．２．３．  ファンクションZM_LOOP_CONTROL


　外部プログラムからループ演奏を制御することも出来る。

  これにはファンクションZM_LOOP_CONTROLを用いる。

			MEASURE10より抜粋
--------------------------------------------------------------------------------
ファンクション$59	ZM_LOOP_CONTROL

機能	ループ制御

引数	d1.l:コントロールモード
	     -1=ループ回数取得
	     0=通常ループ指定
	     1=ループ無視指定

戻り値	d0.l=-1以外:現在のループ回数(1～)
	d0.l=-1:エラー
--------------------------------------------------------------------------------
  d1.l=1として「ループ無視」とすると、演奏中の曲の各トラックがループ終端に

きても、ループ処理を実行せずに、ループ命令の後ろの演奏データを演奏しに行く。

たとえば、MMLで

	[do] cde [loop] fga

とあるとき、「ループ無視」の時は cde fga と演奏する。

　ユーザープログラム側で時間管理を行い、任意のタイミングで「通常ループ」モード

と「ループ無視」モードを切り換えることで、演奏の進行を自由に制御出来る。

　たとえば

	[do] cde [loop] [do] fga [loop]

という演奏データも、通常モードでは fga が演奏されることはないが、無指定モード

と通常モードを外部プログラムで随時切り換えてやることで cde を数回、fdeを

無限ループ演奏させることが可能となる。

  イントロを外部プログラムの都合が付くまで演奏させておく目的などに使える。

2つの違う曲を１つの演奏データ内に存在させ、ノンストップミックス調に曲を

切り換えることも出来る。
